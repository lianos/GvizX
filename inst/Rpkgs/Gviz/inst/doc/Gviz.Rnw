%\VignetteIndexEntry{Gviz users guide}
%\VignetteDepends{Gviz}
%\VignetteKeywords{Visualization}
%\VignettePackage{Gviz}
\documentclass[11pt]{article}

\usepackage[utf8]{inputenc} 

\SweaveOpts{keep.source=FALSE,pdf=TRUE,eps=FALSE}

\usepackage{hyperref}
\usepackage{url}
\usepackage[authoryear,round]{natbib}
\bibliographystyle{plainnat}
\usepackage[text={7.2in,9in},centering]{geometry}
\usepackage{Sweave}
\setkeys{Gin}{width=0.95\textwidth}
\usepackage{longtable}
\usepackage{graphicx}

\newcommand{\R}{{\textsf{R} }}
\newcommand{\code}[1]{{\texttt{#1}}}
\newcommand{\term}[1]{{\emph{#1}}}
\newcommand{\Rpackage}[1]{\textsf{#1}}
\newcommand{\Rfunction}[1]{\texttt{#1}}
\newcommand{\Robject}[1]{\texttt{#1}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\textit{#1}}}
\newcommand{\Rfunarg}[1]{{\textit{#1}}}
\newcommand{\scscst}{\scriptscriptstyle}
\newcommand{\scst}{\scriptstyle}
\newcommand{\mgg}[0]{\Rpackage{Gviz} }
\newcommand{\Reference}[1]{{\texttt{#1}}}
\newcommand{\link}[1]{{#1}}


\author{Florian Hahne\footnote{florian.hahne@novartis.com}}
\begin{document}
\title{The \mgg User Guide}

<<init, echo=FALSE>>=
options(width=65)
library(xtable)
source(system.file("scripts/documentation.R", package="Gviz"))
xtabDetails <- details
addParTable <- function(class, skip=c("showTitle", "size", "background.title"), add=NULL)
{
    Parameters <- data.frame("Display Parameter"=names(xtabDetails[[class]]),
                             "Description"=xtabDetails[[class]], check.names=FALSE)
    align <- "lrp{5in}"
    if(!is.null(add)){
        Parameters <- cbind(Parameters, add)
        align <- c("lp{4in}", "lp{4in}", "lp{4in}", "lp{4in}")
    }
    Parameters <- Parameters[order(Parameters[,1]),]
    Parameters <- apply(Parameters, 2, function(x) gsub("_", "\\_", x, fixed=TRUE))
    rownames(Parameters) <-  gsub("_", "\\_", rownames(Parameters), fixed=TRUE)
    sel <- Parameters[,1] %in% skip
    Parameters[,2] <- gsub("\\code{\\linkS4class{", "\\Rclass{{", Parameters[,2], fixed=TRUE)
    print(xtable(Parameters[!sel,], align=align), sanitize.text.function=function(x) x, include.rownames=FALSE,
          floating=FALSE, tabular.environment="longtable")
    return(invisible())
}

hasUcscConnection <- !is(try(rtracklayer::browserSession(), silent=TRUE), "try-error")
hasBiomartConnection <- !is(try(biomaRt::listMarts(), silent=TRUE), "try-error")

@ 

\maketitle

\tableofcontents
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

In order to make sense of genomic data one often aims to plot such
data in a genome browser, along with a variety of genomic annotation
features, such as gene or transcript models, CpG island, repeat
regions, and so on. These features may either be extracted from public
data bases like ENSEMBL or UCSC, or they may be generated or curated
in-house. Many of the currently available genome browsers do a
reasonable job in displaying genome annotation data, and there are
options to connect to some them from within \R (e.g., using the
\Rpackage{rtracklayer} package). However, none of these solutions
offer the flexibility of the full \R graphics system to display large
numeric data in a multitude of different ways. The \mgg package aims
to close this gap by providing a structured visualization framework to
plot any type of data along genomic coordinates. It is loosely based
on the \Rpackage{GenomeGraphs} package by Steffen Durinck and James
Bullard, however the complete class hierarchy as well as all the
plotting methods have been restructured in order to increase
performance and flexibility. All plotting is done using the grid
graphics system, and several specialized annotation classes allow to
integrate publicly available genomic annotation data from sources like
UCSC or ENSEMBL.


\section{Basic Features}

The fundamental concept behind the \mgg package is similar to the
approach taken by most genome browsers, in that individual types of
genomic features or data are represented by separate tracks. Within
the package, each track constitutes a single object inheriting from
class \Rclass{GdObject}, and there are constructor functions as well
as a broad range of methods to interact with and to plot these
tracks. When combining multiple objects, the individual tracks will
always share the same genomic coordinate system, thus taking the
burden of aligning the plot elements from the user.

It is worth mentioning that at a given time tracks in the sense of the
\mgg package are only defined for a single chromosome on a specific
genome, at least during the plotting operation. You will later see
that a track may still contain information for multiple chromosomes,
however most of this is hidden except for the currently active
chromosome, and the user will have to explicitely switch the chromsome
to access the inactive parts. While the package in principle imposes
no fixed structure on the chromosome or on the genome names, it makes
sense to stick to a standaradized naming paradigm, in particular when
fetching additional annotation information from online resources. By
default this is enforced by a global option
\code{ucscChromosomeNames}, which is set during package loading and
which causes the package to check all supplied chromosome names for
validity in the sense of the UCSC definition (chromosomes have to
start with the \term{chr} string). You may decide to turn this feature
off by calling \code{options(ucscChromosomeNames=FALSE)}. For the
remainder of this vignette however, we will make use of the UCSC
genome and chromosome identifiers, e.g., the \Robject{chr7} chromosome
on the mouse \Robject{mm9} genome.

The different track classes will be described in more detail in the
\Reference{Track classes} section further below. For now, let's just
take a look at a typical \mgg session to get an idea of what this is
all about. We begin our presentation of the available functionality by
loading the package:

<<loadPackage>>=
library(Gviz)
@

The most simple genomic features consists of start and stop
coordinates, possibly overlapping each other. CpG islands or
microarray probes are real life examples for this class of
features. In the Bioconductor world those are most often represented
as run-length encoded vectors, for instance in the \Rclass{IRanges}
and \Rclass{GRanges} classes. To seamlessly integrate with other
Bioconductor packages, we can use the same data structures to generate
our track objects. A sample set of CpG island coordinates has been
saved in the \Robject{cpgIslands} object and we can use that for our
first annotation track object. The constructor function
\Rfunction{AnnotationTrack} is a convenient helper to create the
object.

<<AnnotationTrack>>=
library(GenomicRanges)
data(cpgIslands)
class(cpgIslands)
chr <- as.character(unique(seqnames(cpgIslands)))
gen <- genome(cpgIslands)
atrack <- AnnotationTrack(cpgIslands, name="CpG")
@

Please note that the \Rfunction{AnnotationTrack} constructor (as most
constructors in this package) is fairly flexible and can accomodate
many different types of inputs. For instance, the start and end
coordinates of the annotation features could be passed in as
individual arguments \Robject{start} and \Robject{end}, as a
\Rclass{data.frame} or even as an \Rclass{IRanges} or
\Rclass{GRangesList} object. Furthermore, a whole bunch of coercion
methods are available for the more traditional package users that
should allow operations along the lines of \code{as(obj,
  'AnnotationTrack')}. You may want to consult the class' manual page
for more information, or take a look at the \Reference{Bioconductor
  integration} section for a listing of the most common data
structures and their respective counterparts in the \mgg package.

With our first track object being created we may now proceed to the
plotting. There is a single function \Rfunction{plotTracks} that
handles all of this. As we will learn in the remainder of this
vignette, \Rfunction{plotTracks} is quite powerful and has a number of
very useful additional arguments. For now we will keep things very
simple and just plot the single CpG islands annotation track.

<<plotAnnotationTrack, fig=TRUE, width=7.5, height=0.5>>=
plotTracks(atrack)
@

As you can see, the resulting graph is not particularly
spectacular. There is a title region showing the track's name on a
gray background on the left side of the plot and a data region showing
the seven individual CpG islands on the right. This structure is
similar for all the available track objects classes and it somewhat
mimicks the layout of the popular UCSC Genome Browser. If you are not 
happy with the default settings, the \mgg
package offers a multitude of options to fine-tune the track
appearance, which will be shown in the \Reference{Plotting Parameters}
section.

Appart from the relative distance of the Cpg islands, this
visualization does not tell us much. One obvious next step would be to
indicate the genomic coordinates we are currently looking at to
provide some reference. For this purpose, the \mgg package offers the
\Rclass{GenomeAxisTrack} class. Objects from the class can be created
using the constructor function of the same name.

<<GenomeAxisTrack>>=
gtrack <- GenomeAxisTrack()
@

Since a \Rclass{GenomeAxisTrack} object is always relative to the
other tracks that are plotted, there is little need for additional
arguments. Essentially, the object just tells the
\Rfunction{plotTracks} function to add a genomic axis to the
plot. Nonetheless, it represent a separate annotation track just as
the CpG island track does. We can pass this additional track on to
\Rfunction{plotTracks} in the form of a list.

<<plotGenomeAxisTrack, fig=TRUE, width=7.5, height=1.1>>=
plotTracks(list(gtrack, atrack))
@

You may have realized that the genomic axis does not take up half of
the available vertical plotting space, but only uses the space
necessary to fit the axis and labels. Also the title region for this
track is empty. In general, the \mgg package tries to find reasonable
defaults for all the parameters controlling the look and feel of a
plots so that apealing visualizations can be created without much
tinkering. However, all features on the plot including the relative
track sizes can also be adjusted manually.

As mentioned before in the beginning of this vignette, a plotted track
is always defined for exactly one chromosome on a particular
genome. We can include this information in our plot by means of a
chromosome ideogram. An ideogram is a simplified visual representation
of a chromosome, with the different chromosomal staining bands
indicated by color, and the centromer (if present) indicated by the
shape. The necessary information to produce this visualization is
stored in online data repositories, for instance at UCSC. The \mgg
package offers very convenient connections to some of these
repositories, and the \Rclass{IdeogramTrack} constructor function is
one example for such a connection. With just the information about a
valid UCSC genome and chromosome, we can directly fetch the chromosome
ideogram information and construct a dedicated track object that can
be visualized by \Rfunction{plotTracks}. Please not that you will need
an established internet connection for this to work, and that fetching
data from UCSC can take quite a long time, depending on the server
load. The \mgg package tries to cache as much data as possible to
reduce the bandwidth in future queries.

<<showIdeogramTrack, eval=FALSE>>=
itrack <- IdeogramTrack(genome=gen, chromosome=chr)
@

<<doIdeogramTrack, echo=FALSE, results=hide>>=
if(hasUcscConnection){
    itrack <- IdeogramTrack(genome=gen, chromosome=chr)
}else{
    data(itrack)
}
@

Similar to the previous examples, we stick the additional track object
into a list in order to plot it.

<<plotIdeogramTrack, fig=TRUE, width=7.5, height=1.5>>=
plotTracks(list(itrack, gtrack, atrack))
@

Ideogram tracks are the one exception in all of \mgg's track objects
in the sense that they are not really displayed on the same coordinate
system like all the other tracks. Instead, the current genomic
location is indicated on the chromosome by a red box (or, as in this
case, a red line if the width is too small to fit a box). So far we
have only looked at very basic annotation features and how to give a
point of reference to our plots. Naturally, we also want to be able to
handle more complex genomic features, such as gene models. One
potential use case would be to utilize gene model information from an
existing local source. Alternatively, we could dowload such data from
one of the available online resources like UCSC or ENSEBML, and there
are constructor functions to handle these tasks. For this example we
are going to load gene model data from a stored
\Rclass{data.frame}. The track class of choice here is a
\Rclass{GeneRegionTrack} object, which can be created via the
constructor function of the same name. Similar to the
\Rclass{AnnotationTrack} constructor there are multiple possible ways
to pass in the data.

<<GeneRegionTrack, fig=TRUE, width=7.5, height=3>>=
data(geneModels)
grtrack <- GeneRegionTrack(geneModels, genome=gen, chromosome=chr, name="Gene Model")
plotTracks(list(itrack, gtrack, atrack, grtrack))
@ 

So far the plotted genomic range has been determined by the input
tracks. Unless told otherwise, the package will always display the
region from the leftmost item to the rightmost
item in any of the tracks.  Of course such a static view on a chromosomal region is of
rather limited use. We often want to zoom in or out on a particular
plotting region to see more details or to get a broader overview. To
that end, \Rfunction{plotTracks} supports the \Robject{from} and
\Robject{to} arguments that let us choose an arbitrary genomic range
to plot.

<<zooming, fig=TRUE, width=7.5, height=3>>=
plotTracks(list(itrack, gtrack, atrack, grtrack), from=25e6, to=28e6)
@ 

You may have noticed that the layout of the gene model track has
changed depending on the zoom level. This is a feature of the \mgg
package, which automatically tries to find the optimal visualization
settings to make best use of the available space. At the same time,
when features on a track are too close together to be plotted as
separate items with the current device resolution, the package will
try to reasonably merge them in order to avoid overplotting.

When zooming further in it may become intersting to take a look at the
actual genomic sequence at a given position, and the \mgg package
provides the track class \Rclass{SequenceTrack} that let's you do
that. It can draw the necessary sequence information from one of the 
\Rclass{BSgenome} packages.

<<zooming2, fig=TRUE, width=7.5, height=3.1>>=
library(BSgenome.Hsapiens.UCSC.hg19)
strack <- SequenceTrack(Hsapiens, chromosome=chr)
plotTracks(list(itrack, gtrack, atrack, grtrack, strack), from=26450430, to=26450490, cex=0.8)
@ 

So far we have replicated the features of a whole bunch of other
genome browser tools out there. The real power of the package comes
with a rather general track type, the
\Rclass{DataTrack}. \Rclass{DataTrack} object are essentially
run-length encoded numeric vectors or matrices, and we can use them to
add all sorts of numeric data to our genomic coordinate plots. There
are a whole bunch of different visualization options for these tracks,
from dot plots to histograms to box-and-whisker plots. The individual
rows in a numeric matrix are considered to be different data groups or
samples, and the columns are the raster intervals in the genomic
coordinates. Of course, the data points (or rather the data ranges) do
not have to be evenly spaced; each column is associated with a
particular genomic location. For demonstration purposes we can create
a simple \Rclass{DataTrack} object from randomly sampled data.

<<DataTrack, fig=TRUE, width=7.5, height=4>>=
set.seed(255)
lim <- c(26463500, 26495000)
coords <- sort(c(lim[1], sample(seq(from=lim[1], to=lim[2]), 99), lim[2]))
dat <- runif(100, min=-10, max=10)
dtrack <- DataTrack(data=dat, start=coords[-length(coords)], end=coords[-1], chromosome=chr, 
                    genome=gen, name="Uniform")
plotTracks(list(itrack, gtrack, atrack, grtrack, dtrack), from=lim[1], to=lim[2])
@ 

The first thing to notice is that the title panel to the right of the
plot now contains a y-axis indicating the range of the displayed
data. The default plotting type for numeric vectors is a simple dot
plot. This is by far not the only visualization option, and in a sense
it is waisting quite a lot of information because the run-length
encoded ranges are not immediately apparent. We can change the plot
type by supplying the \Robject{type} argument to
\Rfunction{plotTracks}. A complete description of the available
plotting options is given in section \Reference{Track classes}, and a
more detailed treatment of the so-called 'display parameters' that
control the look and feel of a track is given in the
\Reference{Plotting Parameters} section.

<<DataTrackHist, fig=TRUE, width=7.5, height=4>>=
plotTracks(list(itrack, gtrack, atrack, grtrack, dtrack), from=lim[1], to=lim[2], type="histogram")
@ 

As we can see, the data values in the numeric vector are indeed
matched to the genomic coordinates of the \Rclass{DataTrack}
object. Such a visualization can be particularly helpful when
displaying for instance the coverage of NGS reads along a chromosome,
or to show the measurement values of mapped probes from a micro array
experiment. This concludes our first introduction into the \mgg
package. The remainder of this vignette will deal in much more depth
with the different concepts and the various track classes and plotting
options.

\section{Plotting parameters}

Although not implicitely mentioned before, we have already made use of
the plotting parameter facilities in the \mgg package, or, as we will
call them from now on, the 'display parameters'. Display parameters
are properties of individual track objects (i.e., of any object
inheriting from the base \Rclass{GdObject} class). They can either be
set during object instantiation as additional arguments to the
constructor functions or, for existing track objects, using the
\Rfunction{displayPars} replacement method. In the former case, all
named arguments that can not be matched to any of the constructor's
formal arguments are considered to be display paramters, regardless of
their type or whether they are defined for a particular track class or
not. The following code example rebuilds our \Rclass{GeneRegionTrack}
object with a bunch of display parameters and demonstrates the use of
the \Rfunction{displayPars} accessor and replacement methods.

<<displayPars1, fig=TRUE, width=7.5, height=3>>=
grtrack <- GeneRegionTrack(geneModels, genome=gen, chromosome=chr, name="Gene Model", 
                           showId=TRUE, background.title="brown")
head(displayPars(grtrack))
displayPars(grtrack) <- list(background.panel="#FFFEDB")
head(displayPars(grtrack))
plotTracks(list(itrack, gtrack, atrack, grtrack), from=lim[1], to=lim[2])
@ 

For our gene model track we have now added the gene symbols of the
different transcripts to the plot and changed the background color of
both the title and the data panel. There is a third option to set
display parameters for a single plotting operation (rather than the
permanent setting in the track object) by passing in additional
arguments to the \Rfunction{plotTracks} function. We have already made
use of this feature in the previous data plotting type example. It is
worth mentioning that all display parameters which are passed along
with the \Rfunction{plotTracks} function apply to \emph{all} track
objects in the plot. For some objects classes a particular display
parameter may not make any sense, and in that case it is simply
ignored. Also, the settings only apply for one single plotting
operation and will not be retained in the plotted track objects. They
do however get precedence over the object-internal parameters. The
following line of code exemplifies this behaviour.

<<displayPars2, fig=TRUE, width=7.5, height=3>>=
plotTracks(list(itrack, gtrack, atrack, grtrack), from=lim[1]-1000, to=lim[2], 
           background.panel="#FFFEDB", background.title="darkblue")
@

In order to make full use of the flexible parameter system we need to
know which display parameters control which aspect of which track
class. The obvious source for this information are the man pages of
the respective track classes, which list all available parameters
along with a short description of their effect and default values in
the \Robject{Display Parameters} section. Alternatively, we can use
the \Rfunction{availableDisplayPars} function, which prints out the
available parameters for a class as well as their default values in a
list-like structure. The single argument to the function is either a
class name of a track object class, or the object itself, in which
case its class is automatically detected.

<<displayPars3>>=
dp <- availableDisplayPars(grtrack)
tail(dp)
@ 

As we can see, display parameters can be inherited from parent
classes. For the regular user this is not important at all, however it
nicely exemplifies the structure of the class hierarchy in the \mgg
package.

\section{Track classes}

In this section we will highlight all of the available annotation
track classes in the \mgg package. For the complete reference of all
the nuts and bolts, including all the avaialable methods, please see
the respective class man pages. We will try to keep this vignette up
to date, but in cases of discrepancies between here and the man pages
you should assume the latter to be correct.

\subsection{GenomeAxisTrack}
\Rclass{GenomeAxisTrack} objects can be used to add some reference to
the currently displayed genomic location to a \mgg plot. In their most
basic form they are really just a horizontal axis with genomic
coordinate tickmarks. Using the \Rfunction{GenomeAxisTrack}
constructor function is the recommended way to instantiate objects
from the class. There is no need to know in advance about a particular
genomic location when constructing the object. Instead, the displayed
coordinates will be determined from the context, e.g., from the
\Rfunarg{from} and \Rfunarg{to} arguments of the
\Rfunction{plotTracks} function, or, when plotted together with other
track objects, from their genomic locations.

<<GenomeAxisTrackClass1, fig=TRUE, width=7.5, height=0.5>>=
axisTrack <- GenomeAxisTrack()
plotTracks(axisTrack, from=1e6, to=9e6)
@

As an optional feature one can highlight particular regions
on the axis, for instance to indicated stretches of N nucleotides or
gaps in genomic alignments. Such regions have to be supplied to the
optional \Rfunarg{range} argument of the constructor function as
either an \Rclass{GRanges} or an \Rclass{IRanges} object.

<<GenomeAxisTrackClass2, fig=TRUE, width=7.5, height=0.5>>=
axisTrack <- GenomeAxisTrack(range=IRanges(start=c(2e6, 4e6), end=c(3e6, 7e6)))
plotTracks(axisTrack, from=1e6, to=9e6)
@

\subsubsection*{Display parameters for GenomeAxisTrack objects}
There are a whole bunch of display parameters to alter the appearance
of \Rclass{GenomeAxisTrack} plots. For instance, one could add
directional indicators to the axis using the \Rfunarg{add53} and
\Rfunarg{add35} parameters.

<<GenomeAxisTrackClass3, fig=TRUE, width=7.5, height=0.5>>=
plotTracks(axisTrack, from=1e6, to=9e6, add53=TRUE, add35=TRUE)
@

Sometimes the resolution of the tick marks is not sufficient, in which
case the \Rfunarg{littleTicks} argument can be used to have a more
fine-grained axis annotation.

<<GenomeAxisTrackClass4, fig=TRUE, width=7.5, height=0.5>>=
plotTracks(axisTrack, from=1e6, to=9e6, add53=TRUE, add35=TRUE, littleTicks=TRUE)
@

The \mgg package tries to come up with reasonable defaults for the
axis annotation. In our previous example, the genomic coordinates are
indicated in megabases. We can control this via the \Rfunarg{exponent}
parameter, which takes an integer value greater then zero. The
location of the tick marks are displayed as a fraction of
$10^{exponent}$.

<<GenomeAxisTrackClass5, fig=TRUE, width=7.5, height=0.5>>=
plotTracks(axisTrack, from=1e6, to=9e6, exponent=4)
@

Another useful parameter, \Rfunarg{labelPos} controls the arrangement
of the tick marks. It takes one of the values \code{alternating},
\code{revAlternating}, \code{above} or \code{below}. For instance we
could aline all tick marks underneath the axis.

<<GenomeAxisTrackClass6, fig=TRUE, width=7.5, height=0.5>>=
plotTracks(axisTrack, from=1e6, to=9e6, labelPos="below")
@

Sometimes a full-blown axis is just too much, and all we really need
in the plot is a small scale indicator. We can change the appearance
of the \Rclass{GenomeAxisTrack} object to such a limited
representation by setting the \Rfunarg{scale} display
parameter. Typically, this will be a numeric value between 0 and 1,
which is interpreted as the fraction of the plotting region used for
the scale. The plotting method will apply some rounding to come up
with reasonable and human-readable values. For even more control we
can pass in a value larger than 1, which is considered to be an
absolute range length. In this case, the user is responsible for the
scale to actually fit in the current plotting range.

<<GenomeAxisTrackClass7, fig=TRUE, width=7.5, height=0.5>>=
plotTracks(axisTrack, from=1e6, to=9e6, scale=0.5)
@

We still have control over the placement of the scale label via the
\Rfunarg{labelPos}, parameter, which now takes the values
\code{above}, \code{below} and \code{beside}.

<<GenomeAxisTrackClass8, fig=TRUE, width=7.5, height=0.5>>=
plotTracks(axisTrack, from=1e6, to=9e6, scale=0.5, labelPos="below")
@

For a complete listing of all the available display parameters please
see the table below or the man page of the \Rclass{GenomeAxisTrack}
class by typing in \code{?GenomeAxisTrack} on the \R command line.

<<GenomeAxisTrackClassTable, echo=FALSE, results=tex>>=
addParTable("GenomeAxisTrack")
@ 

\subsection{IdeogramTrack}
While a genomic axis provides helpful points of reference to a plot,
it is sometimes important to show the currently displayed region in
the broader context of the whole chromosme. Are we looking at distal
regions, or somewhere close to the centromer? And how much of the
complete chromosome is covered in our plot. To that end the \mgg
package defines the \Rclass{IdeogramTrack} class, which is an
idealized representation of a single chromosome. When plotted, these
track objects will always show the whole chromosome, regardless of the
selected genomic region. However, the displayed coordinates are
indicated by a box that sits on the ideogram image. The chromosomal
data necessary to draw the ideogram is not part of the \mgg package
itself, instead it is downloaded from an online source (UCSC). Thus it
is important to use both chromosome and genome names that are
recognizable in the UCSC data base when dealing with
\Rclass{IdeogramTrack} objects. You might want to consult the UCSC
webpage (\url{http://genome.ucsc.edu/}) or use the
\Rfunction{ucscGenomes} function in the \Rpackage{rtracklayer} package
for a listing of available genomes.

Assuming the chromosome data are available online, a simple call to
the \Rfunction{IdeogramTrack} constructor function including the
desired genome and chromosome name are enough to instantiate the
object. Since the connection to UCSC can be slow, the package tries to
cache data that has already been downloaded for the duration of the \R
session. If needed, the user can manually clear the cache by calling
the \Rfunction{clearSessionCache} function.

<<IdeogramTrackClass1Show, eval=FALSE>>=
ideoTrack <- IdeogramTrack(genome="hg19", chromosome="chrX")
plotTracks(ideoTrack, from=85e6, to=129e6)
@

<<IdeogramTrackClass1Do, fig=TRUE, width=7.5, height=0.5, echo=FALSE, results=hide>>=
if(hasUcscConnection){
    ideoTrack <- IdeogramTrack(genome="hg19", chromosome="chrX")
}else{
    data(itrack)
}
plotTracks(ideoTrack, from=85e6, to=129e6)
@

We can turn off the explicit plotting of the chromosome name by
setting the \Rfunarg{showId} display parameter to \code{FALSE}.

<<IdeogramTrackClass2, fig=TRUE, width=7.5, height=0.5>>=
plotTracks(ideoTrack, from=85e6, to=129e6, showId=FALSE)
@

\subsubsection*{Display parameters for IdeogramTrack objects}

For a complete listing of all the available display parameters please
see the table below or the man page of the \Rclass{IdeogramTrack}
class by typing in \code{?IdeogramTrack} on the \R command line.

<<IdeogramTrackClassTable, echo=FALSE, results=tex>>=
addParTable("IdeogramTrack")
@ 

\subsection{DataTrack}
Probably the most powerfull of all the track classes in the \mgg
package are \Rclass{DataTracks}. Essentially they constitute
run-length encoded numeric vectors or matrices, meaning that one or
several numeric values are associated to a particular genomic
coordinate range. These ranges may even be overlapping, for instance
when looking at results from a running window operation. There can be
multiple samples in a single data set, in which case the ranges are
associated to the columns of a numeric matrix rather than a numeric
vector, and the plotting method provides tools to incoorporate sample
group information. Thus the starting point for creating
\Rclass{DataTrack} objects will always be a set of ranges, either in
the form of an \Rclass{IRanges} or \Rclass{GRanges} object, or
individually as start and end coordinates or widths. The second
ingredient is a numeric vector of the same length as the number of
ranges, or a numeric matrix with the same number of columns. Those may
even already be part of the input \Rclass{GRanges} object as
\code{elemenMetadata} values. For a complete description of all the
possible inputs please see the class' online documentation. We can
pass all this information to the \Rfunction{DataTrack} constructor function to
instantiate an object. We will load our sample data from an
\Rclass{GRanges} object that comes as part of the \mgg package.

<<DataClass1, fig=TRUE, width=7.5, height=1.5>>=
data(twoGroups)
dTrack <- DataTrack(twoGroups, name="uniform")
plotTracks(dTrack)
@

The default visualization for our very simplistic sample
\Rclass{DataTrack} is a rather unispiring dot plot. The track comes
with a scale to indicate the range of the numeric values on the
y-axis, appart from that it looks very much like the previous
examples. A whole battery of display parameters is to our disposal to
control the track's look and feel. The most important one is the
\Rfunarg{type} parameter. It determines the type of plot to use and
takes one or several of the following values:

<<<types, echo=FALSE, results=tex>>=
types <- data.frame(Value=c("p", "l", "b", "a", "s", "S", "g", "r", "h", "smooth", "histogram", "mountain", "boxplot", "gradient", "heatmap"),
                    Type=c("dot plot", "lines plot", "dot and lines plot", "lines plot of average (i.e., mean) values", "stair steps (horizontal first)",
                           "stair steps (vertical first)", "add grid lines", "add linear regression line", "histogram lines", "add loess curve", 
                           "histogram (bar width equal to range with)", "'mountain-type' plot relative to a baseline", "box and whisker plot",
                           "false color image of the summarized values", "false color image of the individual values"))
print(xtable(types, align="lrp{5in}"), sanitize.text.function=function(x) x, include.rownames=FALSE,
          floating=FALSE, tabular.environment="longtable")
@ 

Displayed below are the same sample data as before but plotted with the different type settings:

<<typePlots, fig=TRUE, width=7.5, height=7.5, echo=FALSE, results=hide>>=
pushViewport(viewport(layout=grid.layout(nrow=8, ncol=2)))
i <- 1
for(t in types$Value)
{
    pushViewport(viewport(layout.pos.col=((i-1)%%2)+1, layout.pos.row=((i-1)%/%2)+1))
    names(dTrack) <- t
    plotTracks(dTrack, type=t, add=TRUE, cex.title=0.8, margin=0.5)
    i <- i+1
    popViewport(1)
}
popViewport(1)
names(dTrack) <- "uniform"
@ 

You will notice that some of the plot types work better for univariate
data while others are clearly designed for multivariate inputs. The
\Rfunarg{a} type for instance averages the values at each genomic
location before plotting the derived values as a line. The decision
for a particular plot type is totally up to the user, and one could
even overlay multiple types by supplying a character vector rather
than a character scalar as the \Rfunarg(type) argument. For example,
this will combine a boxplot with an average line and a data grid.

<<mutitype, fig=TRUE, results=hide, width=7.5, height=1.5>>=
plotTracks(dTrack, type=c("boxplot", "a", "g"))
@ 

\subsubsection*{Data Grouping}

An additional layer of flexibility is added by making use of \mgg's
grouping functionality. The individual samples (i.e., rows in the data
matrix) can be grouped together using a factor variable, and, if
reasonable, this grouping is reflected in the layout of the respective
track types. For instance our example data could be derived from two
different sample groups with three replicates each, and we could easily
integrate this information into our plot.

<<grouping, fig=TRUE, results=hide, width=7.5, height=1.5>>=
plotTracks(dTrack, groups=rep(c("control", "treated"), each=3), type=c("a", "p"))
@ 

For the dot plot representation the individual group levels are
indicated by color coding. For the \Rfunarg{a} type, the averages are
now computed for each group separately and also indicated by two lines
with similar color coding. Grouping is not supported for all plotting
types, for example the \Rfunarg{mountain} type already uses color
coding to convey a different message and for the \Rfunarg{gradient}
type the data are already collapsed to a single variable. The
following gives an overview over some of the other groupable
\Rclass{DataTrack} types. Please note that there are many more display
parameters that control the layout of both grouped and of ungrouped
\Rclass{DataTracks}. You may want to check the class' help page for
details.

<<typeGroupedPlots, fig=TRUE, width=7.5, height=4.9, echo=FALSE, results=hide>>=
pushViewport(viewport(layout=grid.layout(nrow=7, ncol=1)))
i <- 1
for(t in c("a", "s", "smooth", "histogram", "boxplot", "heatmap"))
{
    pushViewport(viewport(layout.pos.col=((i-1)%%1)+1, layout.pos.row=((i-1)%/%1)+1))
    names(dTrack) <- t
    plotTracks(dTrack, type=t, add=TRUE, cex.title=0.8, groups=rep(1:2, each=3), margin=0.5)
    i <- i+1
    popViewport(1)
}
pushViewport(viewport(layout.pos.col=((7-1)%%1)+1, layout.pos.row=((7-1)%/%1)+1))
names(dTrack) <- "hor. hist."
plotTracks(dTrack, type="histogram", stackedBars=FALSE, add=TRUE, cex.title=0.8, groups=rep(1:2, each=3), margin=0.5)
popViewport(2)
names(dTrack) <- "uniform"
@ 

If we need to display some additional information about the individual
group levels we can make use of the \Rfunarg{legend} display parameter
to add a simple legend to the plot. Depending on the plot type and on
some of the other display parameters, the look of this legend may vary
slightly.

<<groupingLegend, fig=TRUE, results=hide, width=7.5, height=1.5>>=
plotTracks(dTrack, groups=rep(c("control", "treated"), each=3), type=c("a", "p"), legend=TRUE)
@ 

\subsubsection*{Data transformations}

The \mgg package offers quite some flexibility to transform data on
the fly. This involves both rescaling operations (each data point is
transformed on the track's y-axis by a transformation function) as
well as summarization and smoothing operations (the values for several
genomic locations are summarized into one derived value on the track's
x-axis). To illustrate this let's create a significantly bigger
\Rclass{DataTrack} than the one we used before, containing purely
syntetic data for only a single sample.

<<biggerdata, fig=TRUE, results=hide, width=7.5, height=1.5>>=
dat <- sin(seq(pi, 10*pi, len=500))
dTrack.big <- DataTrack(start=seq(1,100000, len=500), width=15, chromosome="chrX",
                        genome="hg19", name="sinus", 
                        data=sin(seq(pi, 5*pi, len=500))*runif(500, 0.5, 1.5))
plotTracks(dTrack.big, type="hist")
@ 

Since the available resolution on our screen is limited we can no
longer distinguish between individual coordinate ranges. The \mgg
package tries to avoid overplotting by collapsing overlapping ranges
(assuming the \Rfunarg{collapseTracks} parameter is set to
\code{TRUE}). However, it is often desirable to summarize the data,
for instance by binning values into a fixed number of windows followe
by the calculation of a meaningful summary statistic. This can be
archived by a combination of the \Rfunarg{window} and
\Rfunarg{aggregation} display parameters. The former can be an integer
value greater than zero giving the number of evenly-sized bins to
aggregate the data in. The latter is supposed to be a user-supplied
function that accepts a numeric vector as a single input parameter and
returns a single aggregated numerical value. For simplicity, the most
obvious aggregation functions can be selected by passing in a
character scalar rather than a function. Possible values are
\code{mean}, \code{median}, \code{extreme}, \code{sum}, \code{min} and
\code{max}. These presets are also much faster because they have been
optimized to operate on large numeric matrices. The default is to
compute the mean value of all the binned data points.

<<aggregation, fig=TRUE, results=hide, width=7.5, height=1.5>>=
plotTracks(dTrack.big, type="hist", window=50)
@

Instead of binning the data in fixed width bins one can also use the
\Rfunarg{window} parameter to perform more elaborate running window
operations. For this to happen the parameter value has to be smaller
than zero, and the addtional display parameter \Rfunarg{windowSize}
can be used to control the size of the running window. This operation
does not change the number of coordinate ranges on the plot, but
instead the original value at a particular position is replaced by the
respective sliding window value at the same position. A common use
case for sliding windows on genomic ranges is to introduce a certain
degree of smoothing to the data.

<<aggregation2, fig=TRUE, results=hide, width=7.5, height=1.5>>=
plotTracks(dTrack.big, type="hist", window=-1, windowSize=2500)
@

In addition to transforming the data on the x-axis we can also apply
arbitrary transformation functions on the y-axis. One obvious use-case
would be to log-transform the data prior to plotting. The framework is
flexible enough however to allow for arbitrary transformation
operations. The mechanism works by providing a function as the
\Rfunarg{transformation} display parameter, which takes as input a
numeric vector and returns a transformed numeric vector of the same
length. The following code for instance truncates the plotted data to
values greater than zero.

<<transformation, fig=TRUE, results=hide, width=7.5, height=1.5>>=
plotTracks(dTrack.big, type="l", transformation=function(x){x[x<0] <- 0; x})
@ 

As seen before, the \Rfunarg{a} type allows to plot average values for
each of the separate groups. There is however an additional parameter
\Rfunarg{aggregateGroups} that generalizes group value
aggregations. In the following example we display, for each group and
at each position, the average values in the form of a dot-and-lines
plot.

<<groupingAv1, fig=TRUE, results=hide, width=7.5, height=1.5>>=
plotTracks(dTrack, groups=rep(c("control", "treated"), each=3), type=c("b"), aggregateGroups=TRUE)
@ 

This functionality again also relies on the setting of the
\Rfunarg{aggregation} parameter, and we can easily change it to
display the maximum group values instead.

<<groupingAv2, fig=TRUE, results=hide, width=7.5, height=1.5>>=
plotTracks(dTrack, groups=rep(c("control", "treated"), each=3), type=c("b"), aggregateGroups=TRUE, aggregation="max")
@ 

\subsubsection*{Display parameters for DataTrack objects}

For a complete listing of all the available display parameters please
see the table below or the man page of the \Rclass{DataTrack}
class by typing in \code{?DataTrack} on the \R command line.

<<DataTrackClassTable, echo=FALSE, results=tex>>=
addParTable("DataTrack")
@ 

\subsection{AnnotationTrack}

\Rclass{AnnotationTrack} objects are the multi-purpose tracks in the
\mgg package. Essentially they consist of one or several genomic
ranges that can be grouped into composite annotation elements if
needed. In principle this would be enough to represent everything from
CpG islands to complex gene models, however for the latter the packge
defines the specialized \Rclass{GeneRegionTrack} class, which will be
highlighted in a separate section. Most of the features discussed here
will also apply to \Rclass{GeneRegionTrack} objects, though. As a
matter of fact, the \Rclass{GeneRegionTrack} class inherits directly
from class \Rclass{AnnotationTrack}.

\Rclass{AnnotationTrack} objects are easily instantiated using the
constructor function of the same name. The necessary building blocks
are the range coordinates, a chromosome and a genome identifier. Again
we try to be flexible in the way this information can be passed to the
function, either in the form of separate function arguments, as
\Rclass{IRanges} or \Rclass{GRanges} objects. Optionally, we can pass
in the strand information for the annotation features and some useful
identifiers. A somewhat special case is to build the object from a
\Rclass{GRangesList} object, which will automatically preserve the
element grouping information contained in the list structure. For the
full details on the constructor function and the accepted arguments
see \code{?AnnotationTrack}.

<<anntrack1, fig=TRUE, results=hide, width=7.5, height=0.5>>=
aTrack <- AnnotationTrack(start=c(10, 40, 120), width=15, chromosome="chrX",
                          strand=c("+", "*", "-"), 
                          id=c("Huey", "Dewey", "Louie"), genome="hg19", name="foo")
plotTracks(aTrack)
@ 

The ranges are plotted as simple boxes if no strand information is
available, or as arrows to indicate their direction. We can change the
range item shapes by setting the \Rfunarg{shape} display parameter. It can
also be helpful to add the names for the individual features to the
plot. This can be archived by setting the \Rfunarg{showFeatureId}
parameter to \code{TRUE}

<<anntrack2, fig=TRUE, results=hide, width=7.5, height=0.5>>=
plotTracks(aTrack, shape="box", showFeatureId=TRUE)
@ 

<<anntrack3, fig=TRUE, results=hide, width=7.5, height=0.5>>=
plotTracks(aTrack, shape="ellipse", showFeatureId=TRUE, fontcolor="darkblue")
@ 

In this very simplistic example each annotation feature consisted of a
single range. In real life the genomic annotation features that we
encounter often consists of several sub-units. We can create such
composite \Rclass{AnnotationTrack} objects by providing a grouping
factor to the constructor. It needs to be of similar length as the
total number of atomic features in the track, i.e, the number of
genomic ranges that are passed to the constructor. The levels of the
this factor will be used as internal identifiers for the individual
composite feature groups, and we can toggle on their printing by
setting \Rfunarg{showId} to \code{TRUE}.

<<anntrack4, fig=TRUE, results=hide, width=7.5, height=0.5>>=
aTrack.groups <- AnnotationTrack(start=c(50, 180, 260, 460, 860, 1240), width=c(15,20,40,100,200, 20), 
                                 chromosome="chrX",
                                 strand=rep(c("+", "*", "-"), c(1,3,2)), 
                                 group=rep(c("Huey", "Dewey", "Louie"), c(1,3,2)), 
                                 genome="hg19", name="foo")
plotTracks(aTrack.groups, showId=TRUE)
@ 

Arranging items on the plotting canvas is relatively straight forward
as long as there are no overlaps between invidiual regions or groups
of regions. Those inevitably cause overplotting which could seriously
obfuscate the information on the plot. A logical solution to this
problem is to stack overlapping items in separate horizontal lines to
accomodate all of them. This involves some optimization, and the \mgg
package automatically tries to come up with the most compact
arrangement. Let's exemplify this feature with a slightly modified
\Rclass{AnnotationTrack} object.

<<stacking1,  fig=TRUE, results=hide, width=7.5, height=0.5>>=
aTrack.stacked <- AnnotationTrack(start=c(50, 180, 260, 800, 600, 1240), width=c(15,20,40,100,500, 20), 
                                 chromosome="chrX",
                                 strand="*",
                                 group=rep(c("Huey", "Dewey", "Louie"), c(1,3,2)), 
                                 genome="hg19", name="foo")
plotTracks(aTrack.stacked, showId=TRUE)
@ 

We now have our three annotation feature groups distributed over two
horizontal lines. One can control the stacking of overlapping items
using the \Rfunarg{stacking} display parameter. Currently the three
values \code{squish}, \code{dense} and \code{hide} are
supported. Horizontal stacking is enabled via the \code{squish}
option, which also is the default. \code{dense} forces overlapping
items to be joined in one meta-item and \code{hide} all together
disables the plotting of \Rclass{AnnotationTrack} items. Please note
that adding identifiers to the plot only works for the \code{squish}
option.

<<stacking2,  fig=TRUE, results=hide, width=7.5, height=0.5>>=
plotTracks(aTrack.stacked, stacking="dense")
@

In addition to annotation groups there is also the notion of a feature
type in the \mgg package. Feature types are simply different types of
annotation regions (e.g., mRNA transcripts, miRNAs, rRNAs, etc.) that
are indicated by different colors. There is no limit on the number of
different features, however each element in a grouped annotation item
needs to be of the same feature type. We can query and set features
using the \Rfunction{feature} and \Rfunction{feature<-} methods.

<<features>>=
feature(aTrack.stacked)
feature(aTrack.stacked)[1:4] <- c("foo", "bar", "bar", "bar")
@

Unless we tell the \mgg package how to deal with the respective
feature types they will all be treated in a similar fashion, i.e.,
they will be plotted using the default color as defined by the
\Rfunarg{fill} display paramter. To define colors for individual
feature types we simply have to add them as additional display
parameters, where the parameter name matches to the feature type and
its value is supposed to be a valid R color qualifier. Of course this
implies that we can only use type names that are not already taken by
other display parameters defined in the package.


<<featuresPlot, fig=TRUE, results=hide, width=7.5, height=0.5>>=
plotTracks(aTrack.stacked, showId=TRUE, foo="darkred", bar="darkgreen")
@ 

Stacking of annotation items to avoid overplotting only works as long
as there is enough real estate on the plotting canvas to separate all
items, i.e., we need all items to be at least a single pixel wide to
correctly display them. This limitation is automatically enforced by
the \mgg package, however it implies that unless neighbouring items
are more than one pixel appart we can not distinguish between them and
will inevitably introduce a certain amount of overplotting. This means
that on a common screen device we can only look at a very limited
genomic region of a few kb in full resolution. Given that an average
chromosome is in the order of a few gb, we still need a reasonable way
to deal with the overplotting problem despite the item stacking
functionality. As default, the \mgg package will merge all overlapping
items into one unified meta-item and only plot that (see 'Collapse'
section below for details). In order to indicate the amount of
overplotting that was introduced by this process we can use the
\Rfunarg{showOverplotting} display parameter. It uses a color scale
(based on the orginal colors defined for the track), with lighter
colors indicating areas of low or no overplotting, and more saturated
colors indicating areas of high overplotting density. We exemplify
this feature on an \Rclass{AnnotationTrack} object that represents a
good portion of a real human chromosome.

<<overplotting,  fig=TRUE, results=hide, width=7.5, height=0.75>>=
data("denseAnnTrack")
plotTracks(denseAnnTrack, showOverplotting=TRUE)
@ 



\subsubsection*{Collapsing}
All track types that inherit from class \code{AnnotationTrack} support
the collapsing of overlapping track items, either because they have
initially been defined as overlapping coordinates, or because the
current device resolution does not allow to sufficiently separate
them. For instance, two elements of a feature group may be separated
by 100 base pairs on the genomic scale, however when plotted to the
screen, those 100 base pairs translate to a distance of less than one
pixel. In this case we can no longer show the items as two separate
entitites. One solution to this problem would be to allow for
arbitrary overplotting, in which case the last one of the overlapping
items that is drawn on the device wins. This is not optimal in many
ways, and it also poses a significant burden on the graphical engine
because a lot of stuff has to be drawn which no one will ever see.

To this end the \mgg package provides an infrastructure to reasonably
collapse overlappig items, thereby adjusting the information content
that can be shown to the available device resolution. By default this
feature is turned on, and the user does not have to worry too much
about it. However, one should be aware of the consequences this may
have on a given visualization. If you absolutely do not want
collapsing to take place, you may completely turn it off by setting
the display parameter \code{collapse} to \code{FALSE}. Please note
that by doing this the \code{showOverplotting} parameter will also
stop working. If you opt in, there is some considerable amount of
detailed control to fine tune the collapsing to your needs.

Lets start with a small example track for which element collapsing has
been turned off and no adjustments to the ranges have been made. We
plot both the item identifiers and the group identifiers to exemplify
what is going on.

<<collapse1, fig=TRUE, results=hide, width=7.5, height=0.85>>=
data(collapseTrack)
plotTracks(ctrack, extend.left=1800)
@ 

The first thing to notice is that the for item \code{d} we do see the
item identifier but not the range itself. This is due to the fact that
the with of the item is smaller than a single pixel, and hence the
graphics system can not display it (Note that this is only true for
certain devices. The quartz device on the Mac seems to be a little
smarter about this). There are also the two items \code{e} and
\code{f} which seem to overlay each other completely, and another two
items which appear to be one joined item (\code{k} and
\code{l}). Again, this is a resolution issue as their relative
distance is smaller than a single pixel, so all we see is a single
range and some ugly overplotted identifiers. We can control the first
issue by setting the minimum pixel width of a plotted item to be one
pixel using the \code{min.width} display parameter.

<<collapse2, fig=TRUE, results=hide, width=7.5, height=0.85>>=
plotTracks(ctrack, extend.left=1800, min.width=1)
@ 

Now the item \code{d} has a plotable size and can be drawn to the
device. The overplotted items are still rather anoying, but the only way to
get rid of those is to turn item collapsing back on.
 
<<collapse3, fig=TRUE, results=hide, width=7.5, height=0.85>>=
plotTracks(ctrack, extend.left=1800, min.width=1, collapse=TRUE)
@

Now all items that could not be separated by at least one pixel have
been merged into a single meta-item, and the software has taken care
of the identifiers for you, too. The merging operation is aware of the
grouping information, so no two groups where joint together. Sometimes
a single pixel width or a single pixel distance is not enough to get a
good visualization. In these cases one could decide to enforce even
larger values. We can do this not only for the minimum width, but
also for the minimum distance by setting the \code{min.distance}
parameter.

<<collapse4, fig=TRUE, results=hide, width=7.5, height=0.85>>=
plotTracks(ctrack, extend.left=1800, min.width=3, min.distance=5, collapse=TRUE)
@

This time also the two items \code{b} and \code{c} have been merged,
and all ranges are now at least 3 pixels wide. Depending on the
density of items on the plot even this reduction can be
insufficient. Because we did not merge complete groups we might still
end up with quite a lot of stacks to accomodate all the
information. To this end the display parameter \code{mergeGroups} can
be used to disable absolute group separation. Rather than blindly
merging all groups (as it is done when \code{stacking='dense'})
however, the software will only join those overlapping group ranges
for which all items are already merged into a single meta item.

<<collapse5, fig=TRUE, results=hide, width=7.5, height=0.65>>=
plotTracks(ctrack, extend.left=1800, min.width=3, min.distance=5, collapse=TRUE,
           mergeGroups=TRUE)
@


\subsubsection*{Display parameters for AnnotationTrack objects}

For a complete listing of all the available display parameters please
see the table below or the man page of the \Rclass{AnnotationTrack}
class by typing in \code{?AnnotationTrack} on the \R command line.

<<AnnotationTrackClassTable, echo=FALSE, results=tex>>=
addParTable("AnnotationTrack")
@ 

\subsection{GeneRegionTrack}

\Rclass{GeneRegionTrack} objects are in principle very similar to
\Rclass{AnnotationTrack} objects. The only difference is that they are
a little more gene/transcript centric, both in terms of plotting
layout and user interaction, and that they may define a global start
and end position (a feature which is not particularly relevant for the
normal user). The constructor function of the same name is a
convenient tool to instantiate the object from a variety of different
sources. In a nutshell, we need to pass start and end positions (or
the width) of each annotation feature in the track and also supply the
exon, transcript and gene identifiers for each item which will be used
to create the transcript groupings. A somewhat special case is to
build a \Rclass{GeneRegionTrack} object directly from one of the
popular \Rclass{TranscriptDb} objects, an option that is treated in
more detail below. For more information about all the available
options see the class's manual page (\code{?GeneRegionTrack}).

There are a number of accessor methods that make it easy to query and
replace for instance exon, transcript or gene assignments. There is
also some support for gene aliases or gene symbols which are often
times more useful than cryptic data base gene identifiers. The
following code that re-uses the \Rclass{GeneRegionTrack} object from
the first section exemplifies some of these features.


<<generegtrack,  fig=TRUE, results=hide, width=7.5, height=1.5>>=
data(geneModels)
grtrack <- GeneRegionTrack(geneModels, genome=gen, chromosome=chr, name="foo")
head(gene(grtrack))
head(transcript(grtrack))
head(exon(grtrack))
head(symbol(grtrack))
plotTracks(grtrack, extend.left=20000, showId=TRUE)
@

<<generegtrack2,  fig=TRUE, results=hide, width=7.5, height=2.5>>=
plotTracks(grtrack, extend.left=20000, showId=TRUE, geneSymbols=FALSE)
@

Since we have the gene level information as part of our
\Rclass{GeneRegionTrack} objects we can ask the package to collapse
all of our gene models from individual exons and transcripts down to
gene body locations by setting the \Rfunarg{collapseTranscripts}
display parameter to \code{TRUE}.

<<generegtrack3,  fig=TRUE, results=hide, width=7.5, height=1>>=
plotTracks(grtrack, collapseTranscripts=TRUE, shape="arrow", showId=TRUE, extend.left=20000)
@ 

\subsubsection*{Building GeneRegionTrack objects from TranscriptDbs}

The \Rpackage{GenomicFeatures} packages provides an elegant framework
to download gene model information from online sources and to store it
locally in a SQLite data base. Because these so called
\Rclass{TranscriptDb} objects have become the de-facto standard for
genome annotation information in Bioconductor we tried to make it as
simple as possible to convert them into
\Rclass{GeneRegionTracks}. Essentially one only has to call the
constructor function with the \Rclass{TranscriptDb} object as a single
argument. We exemplify this on a small sample data set that comes with
the \Rpackage{GenomicFeatures} package.

<<tdb2grt1>>=
library(GenomicFeatures)
samplefile <- system.file("extdata", "UCSC_knownGene_sample.sqlite", package="GenomicFeatures")
txdb <- loadDb(samplefile)
GeneRegionTrack(txdb)
@

In this context, the constructor's \Rfunarg{chromosome},
\Rfunarg{start} and \Rfunarg{end} argument take on a slightly differnt
meaning in that they can be used to subset the data that is fetched
from the \Rclass{TranscriptDb} object. Please note that while the
\Rfunarg{chromosome} alone can be supplied, providing \Rfunarg{start}
or \Rfunarg{end} without the chromosome information will not work.

<<tdb2grt2>>=
txTr <- GeneRegionTrack(txdb, chromosome="chr6", start=300000, end=350000)
@

A nice bonus when building \Rclass{GeneRegionTracks} from
\Rclass{TranscriptDb} objects is that we get additional information
about coding and non-coding regions of the transcripts, i.e.,
coordinates of the 5' and 3' UTRs and of the CDS regions. The class'
plotting method can use this inforamtion to distinguish between coding
and non-coding regions based on the shape of the feature. All coding
regions are plotted just as we have seen in the previous examples,
whereas the non-coding regions are drawn as slighly thinner boxes. The
distinction between coding and non-coding is made on the basis of the
object's \code{feature} values in combination with a special display
parameter \code{thinBoxFeature} that enumerates all feature types that
are to be treated as non-coding. Obviously this feature is available
to all \Rclass{GeneRegionTracks}, not only the ones that were build
from \Rclass{TranscriptDb} objects. However, the coding information
has to be added manually and the default value of the
\code{thinBoxFeature} parameter may not be sufficient to cover all
possible cases. It is up to the user to come up with a complete
list of non-coding feature types depending on the source of the data.

<<generegtrack4,  fig=TRUE, results=hide, width=7.5, height=0.25>>=
feature(txTr)
plotTracks(txTr, showId=TRUE, extend.left=1000)
@

\subsubsection*{Display parameters for GeneRegionTrack objects}

For a complete listing of all the available display parameters please
see the table below or the man page of the \Rclass{GeneRegionTrack}
class by typing in \code{?GeneRegionTrack} on the \R command line.

<<GeneRegionTrackClassTable, echo=FALSE, results=tex>>=
addParTable("GeneRegionTrack")
@ 

\subsection{BiomartGeneRegionTrack}

As seen before it can be very useful to quickly download gene
annotation information from an online repositry rather than having to
construct it each time from scratch. To this end, the \mgg package
also defines the \Rclass{BiomartGeneRegionTrack} class, which directly
extends \Rclass{GeneRegionTrack} but provides a direct interface to
the ENSEMBL Biomart service (yet another interface to the UCSC data
base content is highlighted in one of the next sections). Rather than
providing all the bits and pieces for the full gene model, we just
enter a genome, chromosome and a start and end position on this
chromosome, and the constructor function
\Rfunction{BiomartGeneRegionTrack} will automatically contact ENSEMBL,
fetch the necessary information and build the gene model on the
fly. Please note that you will need an internet connection for this to
work, and that contacting Biomart can take a significant amount of
time depending on usage and network traffic. Hence the results are
almost never going to be returned instantaniously.

<<BiomartGeneRegionTrackShow, eval=FALSE>>=
biomTrack <- BiomartGeneRegionTrack(genome="hg19", chromosome=chr, start=20e6, end=21e6,
                                  name="ENSEMBL")
plotTracks(biomTrack)
@ 
<<BiomartGeneRegionTrackDo, echo=FALSE, results=hide, width=7.5, height=1.25, fig=TRUE>>=
if(hasBiomartConnection){
    biomTrack <- BiomartGeneRegionTrack(genome="hg19", chromosome=chr, start=20e6, end=21e6,
                                        name="ENSEMBL")
}else{
    data("biomTrack")
}
plotTracks(biomTrack)
@

You may have noticed in the above plot that the track includes
\code{feature} information which is displayed by the different feature
colors and box sizes. This information has been automatically
extracted from Biomart and the respective color coding is part of the
class' definition. We can highlight the feature classes even more by
using similarly colored bars to connect the grouped elements.

<<BiomartGeneRegionTrackCol, width=7.5, height=1.25, fig=TRUE>>=
plotTracks(biomTrack, col.line=NULL)
@ 

\subsubsection*{Display parameters for BiomartGeneRegionTrack objects}

For a complete listing of all the available display parameters please
see the table above in the previous \Rclass{GeneRegionTrack} section
or the man page of the \Rclass{BiomartGeneRegionTrack} class by typing
in \code{?BiomartGeneRegionTrack} on the \R command line.

As mentioned above, one additional benefit when fetching the data
through Biomart is that we also receive some information about the
annotation feature types, which is automatically used for the color
coding of the track. The following table shows the available feature
types.

<<BiomartGeneRegionTrackClassTable, echo=FALSE, results=tex>>=
addInfo <- t(data.frame(displayPars(biomTrack, names(details[["BiomartGeneRegionTrack"]]))))
colnames(addInfo) <- "Color"
addParTable("BiomartGeneRegionTrack", add=addInfo)
@ 

\subsection{DetailsAnnotationTrack}
It is sometimes desirable to add more detailed information to
particular ranges in an \mgg plot for which the notion of genomic
coordinates no longer makes sense. For instance, the ranges in an
\Rclass{AnnotationTrack} may represent probe locations on a genome,
and for each of these probes a number of measurements from multiple
samples and from different sample groups are available. To this end,
the \Rclass{DetailsAnnotationTrack} provides a flexible interface to
further annotate genomic regions with arbitrary additional
information. This is archived by splitting the
\Rclass{AnnotationTrack} plotting region into two horizontal sections:
the lower section containing the range data in genomic coordinates, and
the upper one containing the additional data for each of the displayed
ranges in verticaly tiled panels of equal size. The connection between
a range item and its details panel is indicated by connecting
lines. 

The content of the individual details panels has to be filled in by a
user-defined plotting function that uses grid (or lattice) plotting
commands. This function has to accept a number of mandatory
parameters, notably the start, end, strand, chromosome and identifier
information for the genomic range, as well as an integer counter
indicating the index of the currently plotted details tile. This
information can be used to fetch abtritray details, e.g. from a list,
and environement or even from a \Rclass{GRanges} object which will
then be processed and visualized within the plotting function. This
may sound rather abstract, and for more details please refer to the
class' help page. For now we just want to demonstrate the
functionality in a simple little example. We begin by defining a
\Rclass{GRanges} object containing 4 genomic locations. In our example
those are considered to be probe locations from a methylation array.

<<DetailsAnnotationTrack1>>=
library(GenomicRanges)
probes <- GRanges(seqnames="chr7", ranges=IRanges(start=c(2000000, 2070000, 2100000, 2160000), end=c(2050000, 2130000, 2150000, 2170000)),
                  strand=c("-", "+", "-", "-"))
@

For each of these probes we have methylation measurements from a large
number of different samples in a numeric matrix, and within the
samples there are two treatment groups. The aim is to compare the
distribution of measurement values between these two groups at each
probe locus.

<<DetailsAnnotationTrack2>>=
methylation <- matrix(c(rgamma(400, 1)), ncol=100, dimnames=list(paste("probe", 1:4, sep=""), NULL))
methylation[,51:100] <- methylation[,51:100] + 0:3
sgroups <- rep(c("grp1","grp2"), each=50)
@

Of course we could use a \Rclass{DataTrack} with the box-plot
representation for this task, however we do have strand-specific data
here and some of the probes can be overlapping, so all this
information would be lost. We are also interested in the particular
shape of the data distribution, so a density plot representation is
what we really need. Luckily, the \Rpackage{lattice} package gives us
a nice \Rfunction{densityplot} function that supports grouping, so all
that's left to do now is to write a little wrapper that handles the
extraction of the relevant data from the matrix. This is easily
archieved by using the range identifiers, which conveniently map to
the row names of the data matrix.

<<DetailsAnnotationTrack3>>=
library(lattice) 
details <- function(identifier, ...) {
    d <- data.frame(signal=methylation[identifier,], group=sgroups)
    print(densityplot(~signal, group=group, data=d, main=list(label=identifier, cex=0.7),
                      scales=list(draw=FALSE, x=list(draw=TRUE)), ylab="", xlab="",
                      ), newpage=FALSE, prefix="plot")
}
@

Finaly, it is as simple as calling the \Rclass{AnnotationTrack}
constructor, passing along the wrapper function and calling
\Rfunction{plotTracks}.

<<DetailsAnnotationTrack4, results=hide, width=7.5, height=5, fig=TRUE>>=
deTrack <- AnnotationTrack(range=probes, genome="hg19", chromosome=7, id=rownames(methylation),
                           name="probe details", stacking="squish",
                           fun=details)
plotTracks(deTrack)
@

It should be noted here that in our little example we rely on the
methylation data matrix and the grouping vector to be present in the
working environment. This is not necessarily the cleanest solution and
one should consider storing additional data in an evironment, passing
it along using the \Rfunarg{detailFunArgs} parameter, or making it
part of the details function in form of a closure. The class' help
page provides further instructions.

Another use case for the \Rclass{DetailsAnnotationTrack} class is to
deal with the problem of very different feature sizes within a single
track. For instance, we may be looking at a rather large genomic
region containing one big transcript with many widely spaced exons and
a bunch of smaller, more compact transcripts. In this case it would be
helpful to provide a zoomed in version of those smaller
transcripts. In order to achieve this we can make use of the class'
\code{groupDetails} display parameter, which applies the detail
plotting function over each range group rather than over individual
range items. First we define a function that selects those groups with
a plotted size smaller than 10 pixels. We make use of the unexported
function \code{.pxResolution} here to come up with the mapping between
pixel coordinates and genomic coordinates.

<<DetailsAnnotationTrack5>>=
selFun <- function(identifier, start, end, track, GdObject, ...){
    gcount <- table(group(GdObject))
    ## This computes the width of 2 pixels in genomic coordinates
    pxRange <- Gviz:::.pxResolution(min.width=20, coord="x")
    return((end-start)<pxRange && gcount[identifier]==1)
}
@

The actual detail plotting function is fairly trivial. In the details
viewport we simply call \code{plotTracks} function on the subset of
items from each group that has been selected before without plotting
the track titles, and also add a scale indicator for some
reference. It is worth mentioning however that we need to extract the
ranges of the zoomed in track items from the unmodified track object
(the \code{Gdobject.original} argument in the details function)
because the object that is plotted in the lower panel contains only
the collapsed ranges.

<<DetailsAnnotationTrack6>>=
detFun <- function(identifier, GdObject.original, ...){
    plotTracks(list(GenomeAxisTrack(scale=0.3, size=0.2, cex=0.7), GdObject.original[group(GdObject.original)==identifier]), 
               add=TRUE, showTitle=FALSE)
}
@ 

Finally, we load some sample data, turn it into a \code{DetailsAnnotationTrack} object and plot it.

<<DetailsAnnotationTrack7, results=hide, width=7.5, height=2, fig=TRUE>>=
data(geneDetails)
deTrack2 <- AnnotationTrack(geneDetails, fun=detFun, selectFun=selFun,
                            groupDetails=TRUE, details.size=0.5, detailsConnector.cex=0.5, detailsConnector.lty="dotted",
                            shape=c("smallArrow", "arrow"), showId=TRUE)
plotTracks(deTrack2, extend.left=90000)
@ 


\subsubsection*{Display parameters for DetailsAnnotationTrack objects}

In addtion to the display parameters for the \Rclass{AnnotationTrack}
class, some additional parameters can be used to control the look and
feel of the details sections. For a complete listing of all the available display parameters please
see the tables below and the one above in the \Rclass{AnnotationTrack} section
or the man page of the \Rclass{DetailsAnnotationTrack} class by typing
in \code{?DetailsAnnotationTrack} on the \R command line.

<<DetailsAnnotationTrack5, results=hide, width=7.5, height=3, fig=TRUE>>=
plotTracks(deTrack, details.size=0.75, detailsConnector.pch=NA, detailsConnector.col="darkred", 
           detailsBorder.fill="#FFE3BF", detailsBorder.col="darkred", shape="box", detailsConnector.lty="dotted")
@ 

<<DetailsAnnotationTrackClassTableSec, echo=FALSE, results=tex>>=
addParTable("DetailsAnnotationTrack")
@ 


\subsection{SequenceTrack}
So far we have displayed all kinds of ranges on a genome, but never
really looked at the underlying genomic sequence. To that end, the
\mgg package defines the \Rclass{SequenceTrack} class which can hold
genomic sequence information derived from either a
\Rclass{DNAStringSet} object of, even more convenient, from one of the
\Rclass{BSgenome} packages. There is not formal checking of the
track's genome, so it is up to the user to provide reasonable inputs
to the class' constructor. As with all the other track types, the
constructor has the same name as the class. In this example we build a
\Rclass{SequenceTrack} from the human hg19 UCSC genome.

<<SequenceTrack1>>=
library(BSgenome.Hsapiens.UCSC.hg19)
sTrack <- SequenceTrack(Hsapiens)
sTrack
@ 

Here we retain the same benefits as for regular \Rclass{BSgenome}
objects in that the actual sequence is only loaded into memory when a
particular chromosome is first accessed. Plotting the track yields the
expected result: a character representation of the genomic sequence in
the current plot window. It may be worth noting that the color scheme
that is used to encode the indvidual nucleotides is defined in the
\Rpackage{biovizBase} package and the user is referred to its
documentation for more details.

<<SequenceTrack2, results=hide, width=7.5, height=0.5, fig=TRUE>>=
plotTracks(sTrack, chromosome=1, from=20000, to=20050)
@ 

Sometimes it may be too busy to plot both the sequence letters and the
color coding, and we can assign arbitrary colors by setting the
\code{fontcolor} display parameter. The convention here is that we
need to supply a named vector, with one entry for each of the five
possible nucleotides (A, C, T, G, and N). If any of the entries is
missing, the respective letter will not be drawn at all.

<<SequenceTrack3, results=hide, width=7.5, height=0.5, fig=TRUE>>=
fcol <- c(A="darkgray", C="darkgray", T="darkgray", G="darkgray")
plotTracks(sTrack, chromosome=1, from=20000, to=20050, fontcolor=fcol)
@ 

In this case we are plotting the sequence on the forward strand and we
may want to make this clear by adding direction indicators.

<<SequenceTrack4, results=hide, width=7.5, height=0.5, fig=TRUE>>=
plotTracks(sTrack, chromosome=1, from=20000, to=20050, add53=TRUE)
@ 

If instead we plot the complement sequence on the reverse strand, the
indicators are automatically adjusted.

<<SequenceTrack5, results=hide, width=7.5, height=0.3, fig=TRUE>>=
plotTracks(sTrack, chromosome=1, from=20000, to=20050, add53=TRUE, complement=TRUE)
@ 

So far we have been able to fit the sequence onto our plotting device
without overplotting. I.e., all the letters nicely fit in to their
respective position in the genomic coordinate system. However this
restricts us to very small windows which we can reasonably display. A
much more compact version of the same information is to use colored
boxes rather than individual letters. Those boxes can be stacked much
closer together, which increases the possible window size quite a
bit. The user does not really need to worry about this as the plotting
method will automatically make a reasonable decision based on the
available space.

<<SequenceTrack6, results=hide, width=7.5, height=0.3, fig=TRUE>>=
plotTracks(sTrack, chromosome=1, from=20000, to=20100)
@ 

For added flexibility one can set the \code{noLetters} display
paramter to \code{TRUE} to always force the drawing of boxes.  Of
course also the colored box represenation of a sequence has its
limits, and if we cross the threshold when individual boxes can not be
separated anymore, the plotting method falls back to drawing a single
line indicating the presence of a sequence at the given position.

<<SequenceTrack7, results=hide, width=7.5, height=0.3, fig=TRUE>>=
plotTracks(sTrack, chromosome=1, from=20000, to=201000)
@

Finally, the selected font size is also contributing to the available
space, and we can cram a little more sequence into a given window by
decreasing it.

<<SequenceTrack8, results=hide, width=7.5, height=0.3, fig=TRUE>>=
plotTracks(sTrack, chromosome=1, from=20000, to=20100, cex=0.5)
@ 


\subsection{Creating tracks from UCSC data}

The UCSC data bases contain a multitude of genome annotation data for
dozents of different organisms. Some of those data are very simple
annotations like CpG island locations or SNP locations. Others are
more complicated gene models, or even numeric annotations like
conservation information. In order to provide a unified interface to
all this information, the \mgg package defines a meta-constructor
function \Rfunction{UcscTrack}. The idea here is that we can express
all of the available Ucsc data in one of the package's track types. We
use the functionality provided in the \Rpackage{rtracklayer} package
to connect to UCSC and to download the relevant information. As a
little illustrative example, let's reproduce a view from the famous
UCSC genome browser using the \mgg package. As a final result we want
to show something similar to Figure~\ref{fig:UCSC1}.

\begin{figure}[htb]
  \centering
  \includegraphics{ucsc1.pdf}
  \label{fig:UCSC1}
  \caption{A screen shot of a UCSC genome browser view around the FMR1
    locus on the mouse chromosome.}
\end{figure}

To start we first need to know about the available data in the UCSC
data base and about their structure. A good way to do this is to use
the table browser on the UCSC web site
(\url{http://genome.ucsc.edu/cgi-bin/hgTables?command=start}). Figure~\ref{fig:UCSC2}
shows the table structure for the first gene model track, the known
UCSC genes, in the table browser. We can see that there are multiple
fields, some with genomic locations, other with additional data like
labels or identifiers. If we go back to the section about the
\Rclass{GeneRegionTrack} class we remember that we need exactly this
type of information for the constructor function. So in order to take
the UCSC data and build an object of class \Rclass{GeneRegionTrack} we
need a way to map them to the individual constructor arguments. This
is exactly what the \Rfunction{UcscTrack} meta-constructor is supposed
to do for us.

\begin{figure}[htb]
  \centering
  \includegraphics{ucsc2.pdf}
  \label{fig:UCSC2}
  \caption{A screen shot of a UCSC table browser view on the UCSC Known Genes track.}
\end{figure}

It needs to know about the track for which to extract the data (and
optionally one or several of the tables that make up the collective
track data, see \code{?UcscTrack} for details), about the genomic
range including the chromosome for which to extract data, about the
type of \mgg track that we want to translate this data into, and about
the individual track columns and their counterparts in the respective
track class constructor. In our example, the track is called
\code{knownGene}, the track type to construct is
\code{GeneRegionTrack}, and the relevant columns are
\code{exonStarts}, \code{exonEnds}, \code{name} and \code{strand},
which we will use as the start and end coordinates of the ranges and
for all the exon, transcript and gene identifiers. Here we make use of
the high flexibility of the \Rfunction{GeneRegionTrack} constructor in
the sense that the exon coordinates actually come in the form of a
comma-separated list, combining all the information for one transcript
in one row of the table. The function is smart enough to detect this
and to split the annotation regions accordingly. The full function
call to create the \Rclass{GeneRegionTrack} from the UCSC data looks
like this:

<<ucscTrack1, eval=FALSE>>=
from <- 65921878
to <- 65980988
knownGenes <- UcscTrack(genome="mm9", chromosome="chrX", track="knownGene", from=from, to=to,
                        trackType="GeneRegionTrack", rstarts="exonStarts", rends="exonEnds", gene="name",
                        symbol="name", transcript="name", strand="strand", fill="#8282d2", name="UCSC Genes")
@ 

With a similar approach we can construct the next two gene model
tracks based on the \code{xenoRefGene} and \code{ensGene} data tables.

<<ucscTrack2, eval=FALSE>>=
refGenes <- UcscTrack(genome="mm9", chromosome="chrX", track="xenoRefGene", from=from, to=to,
                      trackType="GeneRegionTrack", rstarts="exonStarts", rends="exonEnds", gene="name",
                      symbol="name2", transcript="name", strand="strand", fill="#8282d2",
                      stacking="dense", name="Other RefSeq")

ensGenes <- UcscTrack(genome="mm9", chromosome="chrX", track="ensGene", from=from, to=to,
                      trackType="GeneRegionTrack", rstarts="exonStarts", rends="exonEnds", gene="name",
                      symbol="name2", transcript="name", strand="strand", fill="#960000",
                      name="Ensembl Genes")
@ 

The CpG and SNP tracks are slightly different since a
\Rclass{GeneRegionTrack} representation would not be particularly
useful. Instead, we can use \Rclass{AnnotationTrack} objects as
containers. The overall process using the \Rfunction{UcscTrack}
meta-constructor remains the same.

<<ucscTrack3, eval=FALSE>>=
cpgIslands <- UcscTrack(genome="mm9", chromosome="chrX", track="cpgIslandExt", from=from, to=to,
                        trackType="AnnotationTrack", start="chromStart", end="chromEnd", id="name",
                        shape="box", fill="#006400", name="CpG Islands")

snpLocations <-  UcscTrack(genome="mm9", chromosome="chrX", track="snp128", from=from, to=to,
                           trackType="AnnotationTrack", start="chromStart", end="chromEnd", id="name",
                           feature="func", strand="strand", shape="box", stacking="dense", fill="black",
                           name="SNPs")
@ 

Most of UCSC's \Rclass{DataTrack}-like tracks are a little more
complex and represent a collection of several sub-tracks, with data
originating from multiple tables. To make sure that we get the correct
information we have to be a little bit more specific here and also
define the particular table on the UCSC data base to use.

<<ucscTrack4, eval=FALSE>>=
conservation <- UcscTrack(genome="mm9", chromosome="chrX", track="Conservation", table="phyloP30wayPlacental",
                          from=from, to=to, trackType="DataTrack", start="start", end="end", data="score",
                          type="hist", window="auto", col.histogram="darkblue", fill.histogram="darkblue", 
                          ylim=c(-3.7, 4), name="Conservation")

gcContent <- UcscTrack(genome="mm9", chromosome="chrX", track="GC Percent", table="gc5Base",
                       from=from, to=to, trackType="DataTrack", start="start", end="end", data="score",
                       type="hist", window=-1, windowSize=1500, fill.histogram="black", col.histogram="black",
                       ylim=c(30, 70), name="GC Percent")
@ 

To add some reference points we also need a genome axis and an
\Rclass{IdeogramTrack} of the x chromosome.

<<ucscTrack5, eval=FALSE>>=
axTrack <- GenomeAxisTrack()
idxTrack <- IdeogramTrack(genome="mm9", chromosome="chrX")
@ 

And finally we can plot all of our tracks.

<<ucscTrackLoad, echo=FALSE, results=hide>>=
data(ucscItems)
@ 

<<ucscTrack6, fig=TRUE, results=hide, width=7.5, height=5.5>>=
plotTracks(list(idxTrack, axTrack, knownGenes, refGenes, ensGenes, cpgIslands,
                gcContent, conservation, snpLocations), from=from, to=to, showTitle=FALSE)
@

\section{Bioconductor integration}
This short section is supposed to give a very brief overview over the
different track classes in the \mgg package and how those can be
constructed from the typical Bioconductor classes that deal with
genomic data. The list ist by no means complete, and a closer look at
a track class' documentation should provide all the possible options.

\begin{longtable}{ l | l | p{9.5cm} }
  \hline
  Gviz class & Bioconductor class & Method\\
  \hline                        
  AnnotationTrack & IRanges & Constructor + additional arguments \\
   & GRanges & Constructor or setAs method, additional data in elementMetadata \\
   & GRangesList & Constructor or setAs method \\
  \hline
  GeneRegionTrack & IRanges & Constructor + additonal arguments \\
   & GRanges & Constructor or setAs method, additional data in elementMetadata \\
   & GRangesList & Constructor or setAs method, additional data in elementMetadata \\
   & TranscriptDb & Constructor or setAs method \\
  \hline
  DataTrack & IRanges & Constructor + additional data matrix \\
   & GRanges & Constructor or setAs method, numeric data in elementMetadata \\
  \hline
\end{longtable}


\section{Composite plots for multiple chromosomes}

As mentioned in the introduction section, a set of \mgg tracks has to
share the same chromosome when plotted, i.e., only a single chromosome
can be active during a given plotting operation. Consequently, we can
not directly create plots for multiple chromosomes in a single call to
the \Rfunction{plotTracks} function. However, since the underlying
graphical infrastructure of the \mgg package uses grid graphics, we
can build our own composite plot using multiple consecutive
\Rfunction{plotTracks} calls. All we need to take care of is an
adequate layout structure to plot into, and we also need to tell
\Rfunction{plotTracks} not to clear the graphics device before
plotting, which can be archieved by setting the function's
\Rfunarg{add} argument to \code{FALSE}. For details on how to create a
layout structure in the grid graphics system, please see the help page
at \code{? grid.layout)}.

We start by creating an \Rclass{AnnotationTrack} objects and a
\Rclass{DataTrack} object which both contain data for several
chromosomes.

<<multPlot1>>=
chroms <- c("chr1", "chr2", "chr3", "chr4")
maTrack <- AnnotationTrack(range=GRanges(seqnames=chroms, ranges=IRanges(start=1, width=c(100,400,200,1000)),
                                         strand=c("+", "+", "-", "+")), genome="mm9", chromosome="chr1", name="foo")

mdTrack <- DataTrack(range=GRanges(seqnames=rep(chroms, c(10, 40, 20, 100)),
                                   ranges=IRanges(start=c(seq(1,100,len=10), seq(1,400,len=40), seq(1, 200, len=20), 
                                                          seq(1,1000, len=100)), width=9), values=runif(170)), 
                     data="values", chromosome="chr1", genome="mm9", name="bar")
@ 

Now we also want a genome axis and an \Rclass{IdeogramTrack} object to indicate the genomic context.

<<multPlot2>>=
mgTrack <- GenomeAxisTrack(scale=50, labelPos="below", exponent=3)
chromosome(itrack) <- "chr1"
@ 

Finaly, we build a layout in which the plots for each chromosome are
placed in a rectangular grid and repeatedly call
\Rfunction{plotTracks} for each chromosome.

<<multPlot3, fig=TRUE, results=hide, width=7.5, height=4>>=
ncols <- 2
nrows <- length(chroms)%/%ncols
grid.newpage()
pushViewport(viewport(layout=grid.layout(nrows, ncols)))
for(i in seq_along(chroms)){
    pushViewport(viewport(layout.pos.col=((i-1)%%ncols)+1, layout.pos.row=(((i)-1)%/%ncols)+1))
    plotTracks(list(itrack, maTrack, mdTrack, mgTrack), chromosome=chroms[i], add=TRUE)
    popViewport(1)
}
@ 

Maybe an even more compact version of this would be to use the lattice
package for building the actual trellis, with \Rfunction{plotTracks}
as the panel function.

<<multPlot4, fig=TRUE, results=hide, width=7.5, height=4>>=
library(lattice)
chroms <- data.frame(chromosome=chroms)
xyplot(1~chromosome|chromosome, data=chroms, panel=function(x){plotTracks(list(itrack , maTrack, mdTrack, mgTrack), chromosome=x, add=TRUE, showId=FALSE)}, 
       scales=list(draw=FALSE), xlab=NULL, ylab=NULL)
@ 

\clearpage
\section*{SessionInfo}
The following is the session info that generated this vignette:
<<session-info>>=
  sessionInfo()
@ 

\end{document}
